/**
 * Vulnerability Scanner Integration Manager
 * Manages integrations with various vulnerability scanning tools
 */

const NessusIntegration = require('./nessusIntegration');
const OpenVASIntegration = require('./openvasIntegration');
const QualysIntegration = require('./qualysIntegration');
const logger = require('../config/logger');

class VulnerabilityIntegrationManager {
  constructor() {
    this.integrations = new Map();
    this.config = this.loadConfiguration();
    this.healthStatus = new Map();
    this.lastHealthCheck = null;
    this.scanResults = new Map();
    this.activeScanJobs = new Map();
  }

  /**
   * Load vulnerability scanner configurations from environment
   */
  loadConfiguration() {
    return {
      nessus: {
        enabled: process.env.NESSUS_ENABLED === 'true',
        hostname: process.env.NESSUS_HOST,
        port: process.env.NESSUS_PORT || 8834,
        username: process.env.NESSUS_USERNAME,
        password: process.env.NESSUS_PASSWORD,
        accessKey: process.env.NESSUS_ACCESS_KEY,
        secretKey: process.env.NESSUS_SECRET_KEY,
        protocol: process.env.NESSUS_PROTOCOL || 'https',
        verifyCert: process.env.NESSUS_VERIFY_CERT !== 'false',
      },
      openvas: {
        enabled: process.env.OPENVAS_ENABLED === 'true',
        hostname: process.env.OPENVAS_HOST,
        port: process.env.OPENVAS_PORT || 9392,
        username: process.env.OPENVAS_USERNAME,
        password: process.env.OPENVAS_PASSWORD,
        protocol: process.env.OPENVAS_PROTOCOL || 'https',
        verifyCert: process.env.OPENVAS_VERIFY_CERT !== 'false',
      },
      qualys: {
        enabled: process.env.QUALYS_ENABLED === 'true',
        hostname: process.env.QUALYS_HOST || 'qualysapi.qualys.com',
        username: process.env.QUALYS_USERNAME,
        password: process.env.QUALYS_PASSWORD,
        apiUrl: process.env.QUALYS_API_URL,
        subscriptionId: process.env.QUALYS_SUBSCRIPTION_ID,
      },
    };
  }

  /**
   * Initialize all enabled vulnerability scanner integrations
   */
  async initialize() {
    try {
      logger.info('Initializing vulnerability scanner integrations...');

      // Initialize Nessus
      if (this.config.nessus.enabled) {
        await this.initializeIntegration('nessus', new NessusIntegration(this.config.nessus));
      }

      // Initialize OpenVAS
      if (this.config.openvas.enabled) {
        await this.initializeIntegration('openvas', new OpenVASIntegration(this.config.openvas));
      }

      // Initialize Qualys
      if (this.config.qualys.enabled) {
        await this.initializeIntegration('qualys', new QualysIntegration(this.config.qualys));
      }

      logger.info(`Vulnerability scanner integrations initialized: ${Array.from(this.integrations.keys()).join(', ')}`);
    } catch (error) {
      logger.error('Error initializing vulnerability scanner integrations:', error);
      throw error;
    }
  }

  /**
   * Initialize a specific integration
   */
  async initializeIntegration(name, integration) {
    try {
      await integration.initialize();
      this.integrations.set(name, integration);
      this.healthStatus.set(name, { status: 'healthy', lastCheck: Date.now() });
      logger.info(`Vulnerability scanner integration '${name}' initialized successfully`);
    } catch (error) {
      logger.error(`Failed to initialize vulnerability scanner integration '${name}':`, error);
      this.healthStatus.set(name, { status: 'error', error: error.message, lastCheck: Date.now() });
      throw error;
    }
  }

  /**
   * Start a vulnerability scan across specified scanners
   */
  async startScan(scanConfig, targets = null) {
    const targetIntegrations = targets ? 
      Array.from(this.integrations.entries()).filter(([name]) => targets.includes(name)) :
      Array.from(this.integrations.entries());

    const results = [];
    const errors = [];

    for (const [name, integration] of targetIntegrations) {
      try {
        logger.info(`Starting vulnerability scan on: ${name}`);
        const result = await integration.startScan(scanConfig);
        results.push({ integration: name, success: true, result });
        
        // Track active scan job
        this.activeScanJobs.set(`${name}-${result.scanId}`, {
          integration: name,
          scanId: result.scanId,
          status: 'running',
          startTime: Date.now(),
          config: scanConfig,
        });
      } catch (error) {
        logger.error(`Failed to start scan on ${name}:`, error);
        errors.push({ integration: name, error: error.message });
      }
    }

    return { results, errors, success: errors.length === 0 };
  }

  /**
   * Get scan status from all integrations
   */
  async getScanStatus(scanId = null) {
    const status = {};
    const errors = [];

    for (const [name, integration] of this.integrations) {
      try {
        logger.debug(`Getting scan status from: ${name}`);
        const result = await integration.getScanStatus(scanId);
        status[name] = result;
      } catch (error) {
        logger.error(`Failed to get scan status from ${name}:`, error);
        errors.push({ integration: name, error: error.message });
      }
    }

    return { status, errors };
  }

  /**
   * Get scan results from all integrations
   */
  async getScanResults(scanId = null, format = 'json') {
    const results = {};
    const errors = [];

    for (const [name, integration] of this.integrations) {
      try {
        logger.debug(`Getting scan results from: ${name}`);
        const result = await integration.getScanResults(scanId, format);
        results[name] = result;
        
        // Cache results
        this.scanResults.set(`${name}-${scanId}`, {
          results: result,
          timestamp: Date.now(),
          format,
        });
      } catch (error) {
        logger.error(`Failed to get scan results from ${name}:`, error);
        errors.push({ integration: name, error: error.message });
      }
    }

    return { results, errors };
  }

  /**
   * Get vulnerability statistics from all scanners
   */
  async getVulnerabilityStats() {
    const stats = {};
    const errors = [];

    for (const [name, integration] of this.integrations) {
      try {
        logger.debug(`Getting vulnerability stats from: ${name}`);
        const result = await integration.getVulnerabilityStats();
        stats[name] = result;
      } catch (error) {
        logger.error(`Failed to get vulnerability stats from ${name}:`, error);
        errors.push({ integration: name, error: error.message });
      }
    }

    return { stats, errors };
  }

  /**
   * Get scan policies from all scanners
   */
  async getScanPolicies() {
    const policies = {};
    const errors = [];

    for (const [name, integration] of this.integrations) {
      try {
        logger.debug(`Getting scan policies from: ${name}`);
        const result = await integration.getScanPolicies();
        policies[name] = result;
      } catch (error) {
        logger.error(`Failed to get scan policies from ${name}:`, error);
        errors.push({ integration: name, error: error.message });
      }
    }

    return { policies, errors };
  }

  /**
   * Create scan policy across specified scanners
   */
  async createScanPolicy(policyConfig, targets = null) {
    const targetIntegrations = targets ? 
      Array.from(this.integrations.entries()).filter(([name]) => targets.includes(name)) :
      Array.from(this.integrations.entries());

    const results = [];
    const errors = [];

    for (const [name, integration] of targetIntegrations) {
      try {
        logger.info(`Creating scan policy on: ${name}`);
        const result = await integration.createScanPolicy(policyConfig);
        results.push({ integration: name, success: true, result });
      } catch (error) {
        logger.error(`Failed to create scan policy on ${name}:`, error);
        errors.push({ integration: name, error: error.message });
      }
    }

    return { results, errors, success: errors.length === 0 };
  }

  /**
   * Stop a running scan
   */
  async stopScan(scanId, targets = null) {
    const targetIntegrations = targets ? 
      Array.from(this.integrations.entries()).filter(([name]) => targets.includes(name)) :
      Array.from(this.integrations.entries());

    const results = [];
    const errors = [];

    for (const [name, integration] of targetIntegrations) {
      try {
        logger.info(`Stopping scan ${scanId} on: ${name}`);
        const result = await integration.stopScan(scanId);
        results.push({ integration: name, success: true, result });
        
        // Update active scan job status
        const jobKey = `${name}-${scanId}`;
        if (this.activeScanJobs.has(jobKey)) {
          this.activeScanJobs.get(jobKey).status = 'stopped';
        }
      } catch (error) {
        logger.error(`Failed to stop scan on ${name}:`, error);
        errors.push({ integration: name, error: error.message });
      }
    }

    return { results, errors, success: errors.length === 0 };
  }

  /**
   * Export vulnerability data in various formats
   */
  async exportVulnerabilityData(scanId, format = 'csv', targets = null) {
    const targetIntegrations = targets ? 
      Array.from(this.integrations.entries()).filter(([name]) => targets.includes(name)) :
      Array.from(this.integrations.entries());

    const exports = {};
    const errors = [];

    for (const [name, integration] of targetIntegrations) {
      try {
        logger.debug(`Exporting vulnerability data from: ${name}`);
        const result = await integration.exportData(scanId, format);
        exports[name] = result;
      } catch (error) {
        logger.error(`Failed to export data from ${name}:`, error);
        errors.push({ integration: name, error: error.message });
      }
    }

    return { exports, errors };
  }

  /**
   * Get asset inventory from all scanners
   */
  async getAssetInventory() {
    const inventory = {};
    const errors = [];

    for (const [name, integration] of this.integrations) {
      try {
        logger.debug(`Getting asset inventory from: ${name}`);
        const result = await integration.getAssetInventory();
        inventory[name] = result;
      } catch (error) {
        logger.error(`Failed to get asset inventory from ${name}:`, error);
        errors.push({ integration: name, error: error.message });
      }
    }

    return { inventory, errors };
  }

  /**
   * Correlate vulnerabilities across different scanners
   */
  async correlateVulnerabilities(scanResults) {
    const correlatedVulns = new Map();
    const summary = {
      totalVulnerabilities: 0,
      criticalVulnerabilities: 0,
      highVulnerabilities: 0,
      mediumVulnerabilities: 0,
      lowVulnerabilities: 0,
      confirmedByMultipleScanners: 0,
      uniqueHosts: new Set(),
    };

    for (const [scanner, results] of Object.entries(scanResults.results || {})) {
      if (results.vulnerabilities) {
        for (const vuln of results.vulnerabilities) {
          const key = `${vuln.host}-${vuln.port}-${vuln.plugin_id || vuln.nvt_oid || vuln.qid}`;
          
          if (correlatedVulns.has(key)) {
            correlatedVulns.get(key).scanners.push(scanner);
            correlatedVulns.get(key).confirmed = true;
            summary.confirmedByMultipleScanners++;
          } else {
            correlatedVulns.set(key, {
              ...vuln,
              scanners: [scanner],
              confirmed: false,
            });
          }

          summary.totalVulnerabilities++;
          summary.uniqueHosts.add(vuln.host);
          
          // Count by severity
          switch (vuln.severity?.toLowerCase()) {
            case 'critical':
              summary.criticalVulnerabilities++;
              break;
            case 'high':
              summary.highVulnerabilities++;
              break;
            case 'medium':
              summary.mediumVulnerabilities++;
              break;
            case 'low':
              summary.lowVulnerabilities++;
              break;
          }
        }
      }
    }

    summary.uniqueHosts = summary.uniqueHosts.size;

    return {
      correlatedVulnerabilities: Array.from(correlatedVulns.values()),
      summary,
      timestamp: Date.now(),
    };
  }

  /**
   * Get active scan jobs
   */
  getActiveScanJobs() {
    const activeJobs = Array.from(this.activeScanJobs.values()).filter(
      job => job.status === 'running'
    );

    return {
      activeJobs,
      totalActive: activeJobs.length,
      longestRunning: activeJobs.length > 0 ? 
        Math.max(...activeJobs.map(job => Date.now() - job.startTime)) : 0,
    };
  }

  /**
   * Clean up completed scan jobs
   */
  cleanupCompletedJobs(maxAge = 24 * 60 * 60 * 1000) { // 24 hours
    const cutoff = Date.now() - maxAge;
    
    for (const [key, job] of this.activeScanJobs) {
      if (job.status !== 'running' && job.startTime < cutoff) {
        this.activeScanJobs.delete(key);
      }
    }
  }

  /**
   * Perform health check on all integrations
   */
  async performHealthCheck() {
    logger.info('Performing vulnerability scanner integration health check...');
    this.lastHealthCheck = Date.now();

    for (const [name, integration] of this.integrations) {
      try {
        const isHealthy = await integration.healthCheck();
        this.healthStatus.set(name, {
          status: isHealthy ? 'healthy' : 'unhealthy',
          lastCheck: this.lastHealthCheck,
        });
      } catch (error) {
        logger.error(`Health check failed for vulnerability scanner integration '${name}':`, error);
        this.healthStatus.set(name, {
          status: 'error',
          error: error.message,
          lastCheck: this.lastHealthCheck,
        });
      }
    }

    return {
      timestamp: this.lastHealthCheck,
      integrations: Object.fromEntries(this.healthStatus),
      activeScanJobs: this.getActiveScanJobs(),
    };
  }

  /**
   * Get integration capabilities
   */
  getCapabilities() {
    const capabilities = {};

    for (const [name, integration] of this.integrations) {
      capabilities[name] = {
        startScan: typeof integration.startScan === 'function',
        getScanStatus: typeof integration.getScanStatus === 'function',
        getScanResults: typeof integration.getScanResults === 'function',
        stopScan: typeof integration.stopScan === 'function',
        getScanPolicies: typeof integration.getScanPolicies === 'function',
        createScanPolicy: typeof integration.createScanPolicy === 'function',
        exportData: typeof integration.exportData === 'function',
        getAssetInventory: typeof integration.getAssetInventory === 'function',
        healthCheck: typeof integration.healthCheck === 'function',
      };
    }

    return capabilities;
  }

  /**
   * Get all active integrations
   */
  getActiveIntegrations() {
    return Array.from(this.integrations.keys());
  }

  /**
   * Get health status
   */
  getHealthStatus() {
    return {
      lastCheck: this.lastHealthCheck,
      integrations: Object.fromEntries(this.healthStatus),
      activeScanJobs: this.getActiveScanJobs(),
    };
  }
}

module.exports = new VulnerabilityIntegrationManager();